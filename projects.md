# 👋 Hi there, I'm **Mahmoud Megahd**

## 📚 About Me  

💻 Third-year IT student passionate about **web development** with Django.  
⚡ Always curious, always learning — turning ideas into impactful solutions.  

- 🌍 **Location**: Alexandria, Egypt  
- 🎓 **Education**: B.Sc. in Information Technology @ Borg El Arab Technological University  
- 🌐 **Portfolio**: [mego354.github.io](https://mego354.github.io/mego354/)  

---

## 🛠️ Tech Stack  

- 💡 **Languages**: C, Python, JavaScript, SQL  
- 🧩 **Frameworks**: Django, Flask, Bootstrap, Tailwind  
- 🌐 **Web Dev**: HTML, CSS, JavaScript  
- 🔧 **Tools**: Git, GitHub, Chart.js, Google Charts  
- 🧠 **Soft Skills**: Project Management, Critical Thinking  

---

## 🚀 Featured Projects  

### 🔹 [Tailwind Car App](https://github.com/mego354/Tailwind-car-app)  
**E-commerce platform** for car parts using **Django + Tailwind CSS [Watch Demo Page](https://mego354.github.io/Tailwind-car-app/)**.  

✨ **Highlights**:  
- Secure login & authentication  
- Product listings with images  
- Shopping cart + checkout  
- Admin dashboard for management  
- Responsive Tailwind UI  

---

### 🔹 [Production & Packaging Management System](https://github.com/mego354/Honest)  
Factory-focused **Django app** for managing models, sizes, and packaging.  

📦 **Key Features**:  
- Model & piece tracking  
- Quantity management  
- Carton & packaging workflows  
- PDF reports for insights  

---

### 🔹 [Android APK Automation Testing](https://github.com/mego354/Automation-Testing)  
App testing automation with **Appium + Django** [Watch Demo Page](https://mego354.github.io/Automation-Testing/).  

🤖 **Capabilities**:  
- Automated APK testing  
- Emulator integration  
- Real-time feedback & logs  

---

### 🔹 [Hand Gesture Project](https://github.com/mego354/Hand-Gesture-Project)  
Bridging communication for the deaf using **AI + WebRTC** [Watch Demo Page](https://mego354.github.io/Hand-Gesture-Project/).    

✋ **Features**:  
- Gesture → Text/Voice translation  
- Text → Gesture video animations  
- Real-time machine learning with TensorFlow  

---

### 🔹 [Attendance Management System](https://github.com/mego354/Attendance-Management)  
University attendance tracker with **Django** [Watch Demo Page](https://mego354.github.io/Attendance-Management/).  

📊 **Achievements**:  
- Integrated lecture screens  
- Faster & more accurate tracking  

---

### 🔹 [Store Management System](https://github.com/mego354/Al-Asel)  
All-in-one solution for **inventory & sales analysis** [Watch Demo Page](https://mego354.github.io/Al-Asel/).  

📈 **Features**:  
- Graphical sales dashboards  
- Dynamic search  
- Clean & responsive UI  

---

## 📊 GitHub Stats  

![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=mego354&layout=compact&theme=radical)  

---

## 📫 Let’s Connect  

- 📧 **Email**: [mahmoudmegahd010000@gmail.com](mailto:mahmoudmegahd010000@gmail.com)  
- 📸 **Instagram**: [@mahmoud__megahd](https://www.instagram.com/mahmoud__megahd/)  
- 💬 **WhatsApp**: [+201026004642](https://wa.me/201026004642)  
- 🐙 **GitHub**: [mego354](https://github.com/mego354)  

---

## 🏆 Certifications  

- 🎓 [CS50x: Introduction to Computer Science](https://certificates.cs50.io/6fc6d917-bb54-42ae-b0e5-f05bdc756d71.pdf?size=letter) — HarvardX  
- 🎓 [CS50W: Web Programming with Python & JavaScript](https://certificates.cs50.io/2ccf289b-7f0a-4815-9476-d05daf3838a9.pdf?size=letter) — HarvardX  

---
✨ _Always building, always learning._  
-----------------------
# Tailwind Car App - E-commerce Web App for Car Parts

Welcome to the **Tailwind Car App** repository! This is an **E-commerce platform** built using **Django** and **Tailwind CSS**, designed for selling car parts online.

## 🚀 Live Demo
[Visit the Website](https://mego354.github.io/Tailwind-car-app/)

## 📌 Features
- User authentication (Login, Register, Logout)
- Product listing with images and descriptions
- Shopping cart functionality
- Secure checkout process
- Admin dashboard for managing products and orders
- Responsive design with **Tailwind CSS**

## 🛠️ Technologies Used
- **Django** - Backend framework
- **Django-Tailwind** - UI styling
- **SQLite** - Database
- **JavaScript** - Interactive elements
- **HTML5 & CSS3** - Frontend

## 📂 Folder Structure
```
📦 Tailwind-Car-App
├── 📁 carapp (Main Application)
├── 📁 core (Core settings)
├── 📁 tailwindapp (Tailwind CSS Integration)
├── 📁 theme (Frontend styling)
├── 📄 manage.py (Django Management File)
├── 📄 db.sqlite3 (Database)
├── 📄 package.json (Dependencies)
├── 📄 requirements.txt (Python Dependencies)
└── 📄 README.md (Project Documentation)
```

## 🚀 How to Run
1. **Clone the repository:**
   ```sh
   git clone https://github.com/mego354/Tailwind-car-app.git
   cd Tailwind-car-app
   ```
2. **Create a virtual environment & install dependencies:**
   ```sh
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   pip install -r requirements.txt
   ```
3. **Run database migrations:**
   ```sh
   python manage.py migrate
   ```
4. **Start the development server:**
   ```sh
   python manage.py runserver
   ```
5. Open `http://127.0.0.1:8000/` in your browser.

## 📌 Deployment
1. Configure **Gunicorn** and **Whitenoise** for production.
2. Use **Heroku/Vercel/Render** for deployment.
3. Set environment variables and database configurations.

## 📬 Contact
For any inquiries, feel free to reach out:
- 📧 **Email**: [mahmoudmegahd010000@gmail.com](mailto:mahmoudmegahd010000@gmail.com)  
- 🌐 **Portfolio**: [mego354.github.io](https://mego354.github.io/mego354/)  

---
**📝 Note:** Project is not done yet, just a demo so you can 
Modify this file as needed to fit your project.

Happy Coding! 🚀
----------------------
# Android APK Automation Testing with Appium

A Django application designed to automate the testing of APK files on Android devices using Appium.

## 🚀 Live Demo
[Visit the Website](https://mego354.github.io/Automation-Testing/)

## Table of Contents

- [Installation](#installation)
- [Creating an AVD](#creating-an-avd)
- [MySQL Setup](#mysql-setup)
- [Clone the Project](#clone-the-project)
- [Update Database Configuration](#update-database-configuration)
- [Run the Project](#run-the-project)
- [Application Guidance](#application-guidance)

## Installation

To get started, install the following software:

### Java JDK (Java Development Kit)

1. Download the Java JDK from - [Oracle's official website](https://www.oracle.com/java/technologies/downloads/)  .
2. Install the Java JDK on your system.
3. Set the `JAVA_HOME` environment variable to `C:\Program Files\Java\jdk-22`.
4. Update the `PATH` system variable to include `C:\Program Files\Java\jdk-22\bin`.

### Android Studio and SDK

1. Download Android Studio from - [Android Studio's official website.](https://developer.android.com/studio) 
2. If you require emulators, consider downloading and installing Android Studio.
3. Set the `ANDROID_HOME` environment variable to point to your Android SDK directory.
4. Update the `PATH` system variable to include the following:
   - `%ANDROID_HOME%\tools`
   - `%ANDROID_HOME%\build-tools`
   - `%ANDROID_HOME%\platform-tools`

After you install and open Android Studio, install the Android API 35 SDK as follows:

1. In Android Studio Click Tools > SDK Manager.
2. In the SDK Platforms tab, expand the the Android API 35.
3. Click Apply > OK to download and install the selected packages.

### Node.js

1. Download and install Node.js from - [Node.js official website.](https://nodejs.org/en/learn/getting-started/how-to-install-nodejs) 
2. Update the `PATH` system variable to include `C:\Program Files\nodejs\`.

### Appium

1. Install Appium 2.0 by running the following command:
   ```sh
   npm i -g appium@next
   ```
2. Install Appium drivers:
   ```sh
    appium driver install uiautomator2
    appium driver install xcuitest
   ```

### MySQL

1. Download and install MySQL from - [MySQL official website.](https://www.mysql.com/downloads/) 
2. Update the PATH system variable to include C:\Program Files\MySQL\MySQL Server 8.0\bin.

### System Environment Variables
Ensure the following environment variables are correctly set on your system:

| Variable | Value |
| ------ | ------ |
| JAVA_HOME | C:\Program Files\Java\jdk-22 |
| ANDROID_HOME | C:\Users\YOUR_USER_NAME\AppData\Local\Android\Sdk |

PATH: Include the following paths in system variable path:
| Value |
| ------ |
| C:\Program Files\nodejs\ |
| C:\Program Files\Java\jdk-22\bin |
| C:\Program Files\MySQL\MySQL Server 8.0\bin |
| %ANDROID_HOME%\tools |
| %ANDROID_HOME%\build-tools |
| %ANDROID_HOME%\platform-tools |

## Creating an AVD
1. Open Android Studio.
2. Navigate to Tools > AVD Manager.
3. Click on Create Virtual Device.
4. Select a device definition (e.g., Pixel 7 Pro).
5. Choose a system image (API Level 35).
6. Complete the AVD creation process and copy the avd name (e.g., Pixel_7_Pro_API_33).

## MySQL Setup
1. Open MySQL Workbench.
2. Create a new connection.
3. Create a new schema for your project, e.g., django_db.
4. Create a user with all privilege:
   ```sh
    mysql -u root -p
   ```
enter the root's password
   ```sh
    CREATE USER 'username'@'host' IDENTIFIED BY 'password';
    GRANT ALL PRIVILEGES ON *.* TO 'username'@'host' WITH GRANT OPTION;
    FLUSH PRIVILEGES;
    exit
   ```

##  Clone the Project
1. Clone the repository using the following command:

   ```sh
    git clone https://github.com/mego354/Automation-Testing.git
   ```

2. Update Database Configuration
Open project/core/settings.py.
Update the MySQL database connection settings:

   ```python
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'automation_test_db',
            'USER': 'your_username',
            'PASSWORD': 'your_password',
            'HOST': 'localhost',
            'PORT': '3307',
        }
    }
   ```
3. Update the Email credentials
   ```python
   EMAIL_HOST_USER = 'example@gmail.com'  # Replace with your EMAIL account
   EMAIL_HOST_PASSWORD = 'examplepass'  # Replace with your SMTP password 
   ```
you can get SMTP password from gmail 

## Run the Project
1. Change the directory to the project path:
   ```sh
    cd path/to/project
   ```

2. Install necessary libraries:
   ```sh
    pip install -r requirements.txt
   ```

3. Run migrations:

   ```sh
    python manage.py migrate
   ```

4. Create a superuser:

   ```sh
    python manage.py createsuperuser
   ```

5. Start the Django development server:

   ```sh
    python manage.py runserver
   ```

6. Access the app at http://localhost:8000/admin to log in with the superuser credentials.

7. Create an AVD Model:
    - Go to the AVD model in the Django admin panel.
    - Create a new AVD entry with the following details:
    - Name: The name of the device (e.g., Pixel_7_Pro_API_33).
    - SDK Root Path: The SDK root path of your device.
    - Appium Link: http://localhost:4724.

8. Run Appium
Start the Appium server using the following command:

   ```sh
    appium -p 4724
   ```

Once the server is running, you can enter the app route, create applications, and run the automation tests as desired.

## Application Guidance

### Testing:
before using the application you can check the application:
1. Open  project/automation/tests.py
2. Edit lines 133, 134 with the credentials of the craeted AVD Model from before
3. Run appium server `appium -p 4724`
4. run the test using `py manage.py test`

### usage:
1. Run Appium with `appium -p 4724` and verify it's running by checking the logs.
2. Run the app with `py manage.py runserver`.
3. Open the login route at `http://127.0.0.1:8000/login/`.
4. Register a new account or log in with a previously created account.
5. Navigate to `Apps` from the navbar.
6. Click on `Create New App`.
7. Fill in the Name field and upload the APK file (only .apk files are accepted).
8. Test the app using the Run Test button.

###  Check Logs for Errors
Some errors you might encounter if the test does not go well:
1. Your device may not be able to handle the emulator. In this case, try running the test again.
2. The driver might be stuck; if so, restart the Django app. This issue is rare.

### Debugging the Test Process
To see what's happening under the hood:

1. Comment line 67 in project/automation/testing.
2. Uncomment line 64 in project/automation/testing.
3. Restart the server and start the app test again. This will allow you to observe the emulator while the test is running.


    
----------------------
# 🤟 Hand Gesture Communication App

A revolutionary Django web application that bridges the communication gap between deaf and hearing individuals through real-time hand gesture recognition, text-to-sign language conversion, and voice-to-sign language translation.

## 🚀 Live Demo
[Visit the Website](https://mego354.github.io/Hand-Gesture-Project/)

## 🌟 Overview

This application serves as a comprehensive communication platform that enables seamless interaction between deaf and hearing individuals. It combines cutting-edge machine learning, computer vision, and web technologies to provide real-time gesture recognition, text translation, and voice processing capabilities.

## ✨ Key Features

### 🎯 **Core Functionality**
- **Real-time Hand Gesture Recognition**: Live camera feed processing with ML-powered gesture detection
- **Text-to-Sign Language**: Convert written text into sign language videos
- **Voice-to-Sign Language**: Transform voice recordings into sign language videos
- **Bidirectional Communication**: Full communication flow between deaf and hearing users
- **Multi-language Support**: Arabic and English language support

### 🚀 **Advanced Features**
- **Modern WebSocket Communication**: Real-time updates and instant feedback
- **Responsive Design**: Mobile-friendly interface that works on all devices
- **Video Processing**: Advanced video concatenation and optimization
- **Speech Recognition**: High-accuracy voice-to-text conversion
- **Session Management**: Track and manage communication sessions
- **Error Handling**: Comprehensive error management and user feedback

## 🛠 Technology Stack

### **Backend**
- **Django 4.2+**: Modern web framework with class-based views
- **Django Channels**: WebSocket support for real-time communication
- **TensorFlow/Keras**: Machine learning model for gesture recognition
- **OpenCV**: Computer vision and video processing
- **MediaPipe**: Hand detection and tracking
- **SpeechRecognition**: Voice-to-text conversion
- **PyDub**: Audio processing and format conversion

### **Frontend**
- **Modern JavaScript**: ES6+ with async/await patterns
- **TensorFlow.js**: Browser-based machine learning
- **WebRTC API**: Camera and microphone access
- **Bootstrap 5**: Responsive UI framework
- **CSS3**: Modern styling with animations and transitions

### **Infrastructure**
- **SQLite**: Lightweight database (easily upgradeable to PostgreSQL)
- **Redis**: Channel layer for WebSocket communication
- **FFmpeg**: Video processing and format conversion
- **WebSockets**: Real-time bidirectional communication

## 📋 Prerequisites

- **Python 3.8+**
- **Redis Server** (for WebSocket functionality)
- **Webcam Access** (for gesture recognition)
- **Modern Web Browser** (Chrome, Firefox, Safari, Edge)
- **FFmpeg** (for video processing)

## 🔧 Installation & Setup

### 1. **Clone the Repository**
```bash
git clone https://github.com/yourusername/Hand-Gesture-Project.git
cd Hand-Gesture-Project
```

### 2. **Create Virtual Environment**
```bash
python -m venv venv

# Windows
venv\Scripts\activate

# macOS/Linux
source venv/bin/activate
```

### 3. **Install Dependencies**
```bash
pip install -r requirements.txt
```

### 4. **Install Redis**
```bash
# Ubuntu/Debian
sudo apt-get install redis-server
sudo systemctl start redis-server

# macOS
brew install redis
brew services start redis

# Windows
# Download from: https://github.com/microsoftarchive/redis/releases
```

### 5. **Install FFmpeg**
```bash
# Ubuntu/Debian
sudo apt-get install ffmpeg

# macOS
brew install ffmpeg

# Windows
# Download from: https://ffmpeg.org/download.html
```

### 6. **Database Setup**
```bash
python manage.py makemigrations
python manage.py migrate
python manage.py createsuperuser
```

### 7. **Run the Application**
```bash
python manage.py runserver
```

### 8. **Access the Application**
Open your browser and navigate to: `http://localhost:8000`

## 🎮 Usage Guide

### **For Deaf Users**
1. **Gesture Recognition**: Use the live stream feature to perform hand gestures
2. **View Responses**: Receive text and voice messages from hearing users
3. **Session Management**: Track your communication history

### **For Hearing Users**
1. **Text Input**: Type messages that get converted to sign language videos
2. **Voice Recording**: Record voice messages for automatic conversion
3. **View Gestures**: Watch sign language videos from deaf users

### **Communication Flow**
```
Deaf User (Gestures) → Text/Voice → Hearing User
Hearing User (Text/Voice) → Sign Language Video → Deaf User
```

## 🔌 API Endpoints

### **Core Endpoints**
- `POST /upload_text/` - Convert text to sign language
- `POST /upload_voice/` - Convert voice to sign language
- `POST /upload/` - Upload gesture videos for recognition
- `GET /stream/` - Live gesture recognition interface
- `GET /response/` - Communication interface

### **API Usage Examples**

#### **Text to Sign Language**
```bash
curl -X POST http://localhost:8000/upload_text/ \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "text_input=Hello World"
```

#### **Voice to Sign Language**
```bash
curl -X POST http://localhost:8000/upload_voice/ \
  -F "voiceNote=@recording.webm"
```

#### **Response Format**
    ```json
    {
  "success": true,
  "text": "Hello World",
  "videosrc": "/media/concatenated_video.mp4",
  "message": "Text converted to sign language successfully"
}
```

## 🏗 Project Structure

```
Hand-Gesture-Project/
├── myprojectv3/                 # Django project configuration
│   ├── settings.py             # Main settings
│   ├── asgi.py                 # ASGI configuration
│   └── urls.py                 # URL routing
├── video_app/                  # Main application
│   ├── models.py               # Database models
│   ├── views.py                # Class-based views
│   ├── forms.py                # Django forms
│   ├── consumers.py            # WebSocket consumers
│   ├── routing.py              # WebSocket routing
│   ├── video_processing.py     # Video processing logic
│   ├── middleware.py           # Custom middleware
│   ├── utils.py                # Utility functions
│   ├── models/                 # ML models
│   │   └── model.h5           # Gesture recognition model
│   └── templates/              # HTML templates
│       ├── index.html         # Homepage
│       ├── text_to_sign.html  # Text conversion interface
│       ├── voice_to_sign.html # Voice conversion interface
│       ├── response.html      # Communication interface
│       └── stream.html        # Live gesture recognition
├── media/                      # Media files and videos
├── logs/                       # Application logs
└── requirements.txt            # Python dependencies
```

## 🎯 Key Components

### **Models**
- **HandGesture**: Stores recognized gestures and metadata
- **TextToSign**: Manages text-to-sign language conversions
- **VoiceToSign**: Handles voice-to-sign language processing
- **GestureSession**: Tracks user sessions and interactions

### **Views**
- **TextToSignView**: Handles text input and conversion
- **VoiceToSignView**: Manages voice recording and processing
- **StreamView**: Real-time gesture recognition interface
- **ResponseView**: Communication interface for both user types

### **WebSocket Consumers**
- **GestureConsumer**: Real-time gesture processing
- **CommunicationConsumer**: Bidirectional communication handling

## 🛡 Security Features

- **CSRF Protection**: Built-in Django CSRF protection
- **Input Validation**: Comprehensive form and data validation
- **File Type Validation**: Secure file upload handling
- **XSS Protection**: Cross-site scripting prevention
- **Rate Limiting**: API abuse prevention
- **Request Logging**: Comprehensive audit trail

## 🚀 Deployment

### **Production Setup**

1. **Environment Configuration**
```python
DEBUG = False
ALLOWED_HOSTS = ['yourdomain.com']
SECRET_KEY = 'your-secret-key'
```

2. **Database Configuration**
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_db_name',
        'USER': 'your_db_user',
        'PASSWORD': 'your_db_password',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

3. **Redis Configuration**
```python
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('your-redis-host', 6379)],
        },
    },
}
```

4. **Production Server**
```bash
pip install gunicorn uvicorn
gunicorn myprojectv3.asgi:application -w 4 -k uvicorn.workers.UvicornWorker
```

## 🐛 Troubleshooting

### **Common Issues**

1. **Redis Connection Error**
   ```bash
   redis-cli ping  # Should return PONG
   sudo systemctl start redis-server
   ```

2. **Camera Access Denied**
   - Grant camera permissions in browser
   - Use HTTPS for production (required for camera access)

3. **Model Loading Error**
   - Ensure `model.h5` exists in `video_app/models/`
   - Check file permissions and TensorFlow installation

4. **WebSocket Connection Failed**
   - Verify Redis is running
   - Check firewall settings
   - Ensure WebSocket support in browser

## 🤝 Contributing

We welcome contributions! Please follow these steps:

1. **Fork the repository**
2. **Create a feature branch**: `git checkout -b feature/amazing-feature`
3. **Commit your changes**: `git commit -m 'Add amazing feature'`
4. **Push to the branch**: `git push origin feature/amazing-feature`
5. **Open a Pull Request**

### **Development Guidelines**
- Follow PEP 8 style guidelines
- Add tests for new features
- Update documentation as needed
- Ensure all tests pass before submitting

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- **Django Team** for the excellent web framework
- **TensorFlow Team** for machine learning capabilities
- **MediaPipe Team** for hand detection technology
- **OpenCV Community** for computer vision tools
- **SpeechRecognition Library** for voice processing
- **Bootstrap Team** for responsive UI components

## 📞 Support & Contact

- **Issues**: [GitHub Issues](https://github.com/yourusername/Hand-Gesture-Project/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/Hand-Gesture-Project/discussions)
- **Email**: your.email@example.com

## 🌟 Future Enhancements

- [ ] Multi-language sign language support
- [ ] Mobile app development (React Native/Flutter)
- [ ] Advanced gesture recognition with more gestures
- [ ] Integration with external communication platforms
- [ ] Offline mode support
- [ ] Advanced analytics and usage tracking

---

**Made with ❤️ for the deaf and hard-of-hearing community**

*This application represents a significant step forward in accessible communication technology, bridging the gap between deaf and hearing individuals through innovative use of machine learning and web technologies.*

----------------------
## Attendance Management and Display System

**Project Overview**

This project tackles common challenges faced in educational settings by providing a comprehensive solution to streamline and enhance classroom management. It consists of a website and a display system that work together to improve the efficiency and security of student attendance tracking while providing essential session information.

## 🚀 Live Demo
[Visit the Website](https://mego354.github.io/Attendance-Management/)

* **Website:** Automates attendance recording, saving time for both students and instructors while ensuring accurate and secure data.
* **Display System:** Shows real-time information about ongoing sessions, providing students with quick access to details.

By integrating advanced programming, networking, and display technologies, this project offers a cohesive solution for modern educational institutions. It aims to simplify administrative tasks, improve security, and enhance the accessibility of classroom information for students.

## Project Branches

**1. Web Application** (Main Branch)

* Controls student attendance and manages data for the current session in the room.

**2. Screens for Display**

* Utilizes Dwin screens controlled via a microcontroller to display session data, including professor information and additional details.

**3. Network Management**

* Establishes a wide-ranging network through access points to allow students and screens to connect to the main website.

## Web Application

This Django application offers a robust solution for managing attendance seamlessly.

* **Data Structure:** Includes entities like students, courses, lectures, labs, groups, and classes.
* **Session Management:** Allows for creating, editing, and deleting sessions.
* **Attendance Tracking:** Enables students to submit attendance requests via the website.

**Additional Features:**

* Automated session closure ensures attendance cannot be submitted after a session has begun (prevents manipulation).
* Automatic generation of attendance reports in Excel format and email delivery to instructors streamlines data analysis and record-keeping.

## Technologies Used

* Django (Web Framework)
* JavaScript
* Bootstrap (Front-end Framework)
* ipware (IP Geolocation)
* threading (Multitasking)
* openpyxl (Excel File Generation)
* EmailMessage (Email Sending)

**Web Application Features**

* **Authentication:** Admin and user roles with distinct functionalities.

    * **Admin can:**
        * Create events (lectures, labs) by selecting the course, lecturer, date, and student group.
        * Edit or delete events as needed.
        * Prepare events for student attendance.
   
  ![Device Detection](media/img1.png)

    * **User can:**
        * Update their personal data (password, device).
        * View the daily lecture schedule for efficient planning.
        * Scan QR codes to attend lectures conveniently.
        
           ![Device Detection](media/img2.png)

* **Device Detection:** Utilizes ipware to identify:
    * Device type and brand for potential security checks.
    * Network IP to verify if the student is physically present in the lecture hall (prevents unauthorized attendance).
    * Device criteria against the database to ensure it belongs to the registered student (prevents proxy attendance).
    
  ![Device Detection](media/img3.png)

* **API for Display Screens:** Delivers session data in JSON format, including:
    * Case (1 - Professor with image, 2 - Professor without image, 3 - No session)
    * Students (Group information)
    * Session Type (Lecture, Lab)
    * Department Name
    * College Name
    * Professor Name
    * Subject Name (Course)
    * Time
    * pic_id (Professor image ID in screen memory)

* **Image Management for Screens:**
    * A function creates and stores professor images in a designated folder for display.
    * Main images include homepage, loading page, empty image for professors without a system image, and an info page for messages (empty room, errors).
    * A script creates a zip file of all images for easy transfer to the screens.

  ![Home Page](media/img4.jpg)

## Screens for Display

This section presents session details on Dwin 7-inch screens.

**Hardware**

* ESP32 Microcontroller
* DWIN 7-inch screen model "DMG80480T70_15WTR"
* Custom PCB designed for the circuit
* UART communication protocol

**Software**

* DGUS software by DWIN Technology
    * Allows for page creation, text display, touch interaction, audio, and more.
    * Focuses on page and text display initially for clear information presentation.
    * Each text has a unique VP address for memory access and string display.

  ![Image of DGUS software](media/img5.png)

* Microcontroller Software
    * ESP32-WROOM-32 with integrated WIFI for network connectivity.
    * Connects to the network and sends GET requests to the web application's API to retrieve data.
    * Receives JSON data of the current session in the room (or upcoming session if none is active).
    * Processes the data
    * see the src [here](DWIN/ESP_DWIN.c)

To Finally produce This:

  ![Final Look](media/img6.jpeg)


**Additional Resources**


* Watch a video demonstration of the Web app in action: [Click Here](https://youtu.be/6o3CpS-8aC4).

* Watch a video of the screens: [Click Here](https://youtu.be/HJsce49xAmY).

**THANKS!**

----------------------
# Al Asel Store Management System

Al Asel is a kit shop owned by a friend, specializing in selling equipment and related items. Currently, transactions are managed using Excel, which may not be the most efficient or accurate method. To address this, I envisioned a specialized system tailored for managing the store's operations, from inventory and orders to client management and sales analysis. This report outlines the key components and functionalities of the proposed system.

## 🚀 Live Demo
[Visit the Website](https://mego354.github.io/Al-Asel/)

## Technologies Used
- Django
- JavaScript
- HTML
- CSS
- Chart.js
- Google Fonts
- Google Charts
- Font Awesome

## Features

### File Structure
- **HTML Pages**: Over 25 HTML pages and 2 layout templates (one for main pages, one for alternate pages).
- **Static Files**: Logo, main CSS file containing all styles.
- **JavaScript Files**: Functions utilized across different HTML pages to optimize code reuse.

### Running the Application
1. **Creating an Order**:
   - Cashiers can select products, specify quantities, and select the client and order type (regular, wholesale).
   - Additional actions such as adding offers, modifying prices or quantities, and adding/removing items are possible.
   
2. **Inserting an Order**:
   - Users can input orders made by the owner, specifying quantities, identifying the seller, and selecting the accepting branch.
   - Orders are sorted from the most recent to the oldest, allowing for easy tracking and management.
   - Features are available for modifying orders, including adjusting prices and ensuring orders are closed once edited to prevent potential bugs.

### Clients and Orders View
- **Clients**: View all clients and their orders, with search functionality by name or ID. Each client page displays orders and payment details, including unpaid amounts.
- **Orders**: Orders are arranged by the most recent ones, with search functionality by order ID. Orders contain links for editing, deleting, and managing payments.

### Sales Analysis
- **Sales Overview**: Comprehensive overview of sales data across all years.
- **Yearly Breakdown**: Analyze sales trends and revenue generated for each year.
- **Monthly Analysis**: Explore sales data on a monthly basis, tracking fluctuations and identifying peak periods.
- **Graphical Representation**: Bar graphs and pie charts from Chart.js and Google Charts enhance data interpretation.
- **Detailed Reports**: Specific sales metrics, including total revenue, average order value, and top-selling products.

### Project Distinctiveness and Complexity
- Utilization of around 7 models, demonstrating originality and depth in design.
- Integration of external resources (Chart.js, Google Charts, Font Awesome icons, Google Fonts) enhancing the visual appeal and functionality of the application.
- The system addresses real-life business needs, offering a tailored solution for managing a retail store's operations efficiently.
- Accommodates various scales of operation and is not limited to mobile devices, ensuring flexibility and usability across different contexts.

### Development Insights
- **Model Creation**: Created models for customers, orders, items, and categories.
- **OrderItem Class**: To manage order items efficiently, including tracking prices and quantities.
- **Order Management**: Implemented features to manage order items, including saving, editing, and deleting orders while maintaining consistency in item prices and quantities.

### Views and Templates
- **Order Views**: Functions for making, editing, and adding items to orders, ensuring only items not already in the order are visible.
- **Client and Order Management**: Flexible editing, deleting, and adding features for both orders and client details.
- **Sales Views**: Graphical representation of sales data, with detailed analysis and reports for strategic decision-making.

### Additional Features
- **Sidebar**: Links to create new items, clients, and categories. View all orders, inserted orders, and orders with unpaid amounts. Comprehensive item view for editing items.

## Conclusion
The Al Asel Store management system is a comprehensive solution designed to streamline operations and enhance efficiency in managing inventory, orders, clients, and sales analysis. Its distinctive features, complexity, and integration of external resources make it a robust solution for modern retail management needs. I am extremely proud of achieving such a high level of flexibility and efficiency.

[Demo Video](https://youtu.be/0q1bPAbHGvk)

**THANKS!**
